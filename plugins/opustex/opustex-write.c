/* 
Gregorio OpusTeX output format.
Copyright (C) 2007-2009 Elie Roux <elie.roux@telecom-bretagne.eu>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if ALL_STATIC == 0
    #include <gregorio/plugin.h>
#endif
#include <gregorio/struct.h>
#include <gregorio/unicode.h>
#include <gregorio/characters.h>
#include <gregorio/messages.h>

#include "opustex.h"

#if ALL_STATIC == 0
DECLARE_PLUGIN(opustex)
{
  .id = "otex",
  .name = "opustex",
  .description = "OpusTeX output plugin",
  .author = "Elie Roux <elie.roux@enst-bretagne.fr>",

  .file_extension = "tex",

  .type = GREGORIO_PLUGIN_OUTPUT,

  .write = write_score
};
#endif

int i;
int clef;
char loff = 0;
char centered = 0;
char italic = 0;
char key_change = 0;
char new_line = 0;

#if ALL_STATIC == 0
void
write_score (FILE * f, gregorio_score * score)
#else
void
opustex_write_score (FILE * f, gregorio_score * score)
#endif
{
  char first_syllable = 0;
  char clef_letter;
  int clef_line;
  gregorio_character *first_text;
  gregorio_syllable *current_syllable = score->first_syllable;

  if (!f) {
      gregorio_message (_
			   ("call with NULL file"),
			   "gregoriotex_write_score", ERROR, 0);
			   return;
  }

  if (score->number_of_voices != 1)
    {
      gregorio_message (_
			   ("opustex only works in monophony (for the moment)"),
			   "opustex_write_score", ERROR, 0);
    }

  fprintf(f, "%% File generated by gregorio %s\n", VERSION);
  fprintf (f,
	   "\\input opustex\n\\input opusgre\n\\input opuscho\n\n\\setgregorian1\n");
  // first we draw the initial (first letter) and the initial key
  if (score->first_voice_info)
    {
      gregorio_det_step_and_line_from_key (score->first_voice_info->
					      initial_key, &clef_letter,
					      &clef_line);
      if (clef_letter == 'f')
	{
	  fprintf (f, "\\setclefsymbol1\\gregorianFclef\n\\setclef1%d\n",
		   clef_line + 2);
	}
      else
	{
	  fprintf (f, "\\setclef1%d\n", clef_line);
	}
    }
  else
    {
      fprintf (f, "\\setclef13\n");
    }
  // a char that will contain 1 if it is the first syllable and 0 if not. It is for the initial.
  fprintf (f,
	   "\\musicindent10mm\n\\raisesong3\\Internote\n\\initiumgregorianum\n");
  first_text = gregorio_first_text (score);
  if (first_text)
    {
      fprintf (f, "\\musicinitial{}{");
      gregorio_write_initial (first_text, f,
				      (&otex_write_verb),
				      (&otex_print_char),
				      (&otex_write_begin),
				      (&otex_write_end),
				      (&otex_write_special_char));
      fprintf (f, "}%%\n");
      first_syllable = SKIP_FIRST_LETTER;
    }

  clef = score->first_voice_info->initial_key;
  current_syllable = score->first_syllable;
  while (current_syllable)
    {
      opustex_write_syllable (f, current_syllable,
					  &first_syllable);
      current_syllable = current_syllable->next_syllable;
    }
  fprintf (f, "\\bye\n");
}


char
opustex_is_out_of_neume (gregorio_syllable * syllable)
{
  if (!(syllable->text) && !(syllable->elements[1])
      && syllable->elements[0]->type != GRE_ELEMENT)
    {
      return 1;
    }
  return 0;
}

char
is_even (int c)
{
  if (c % 2 == 0)
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

void
opustex_write_syllable (FILE * f, gregorio_syllable * syllable,
				    char *first_syllable)
{
  char finis = 0;
  char next_note;
  int nextposition = 0;

  gregorio_element *current_element = syllable->elements[0];
  if (opustex_is_out_of_neume (syllable))
    {
      if (current_element->type == GRE_BAR)
	{
	  if (syllable->next_syllable)
	    {
	      fprintf (f, "\\");
	      opustex_write_barline (f,
						 current_element->
						 element_type);
	      fprintf (f, "\n\\spatium\n");
	      current_element = current_element->next;
	    }
	  else
	    {
	      fprintf (f, "\\");
	      opustex_write_finis (f,
					       current_element->element_type);
	      fprintf (f, "\n");
	      finis = 1;
	    }
	  key_change = 0;
	  new_line = 0;
	  return;
	}
      if (current_element->type == GRE_SPACE)
	{
	  switch (current_element->element_type)
	    {
	    case SP_NO_SPACE:
	      fprintf (f, "\\nonspatium\n");
	      break;
	    case SP_ZERO_WIDTH:
	      fprintf (f, "\\Nonspatium\n");
	      break;
	    case SP_NEUMATIC_CUT:
	      fprintf (f, "\\spatiumparvum\n");
	      break;
	    case SP_LARGER_SPACE:
	      fprintf (f, " \\spatiumparvum\n");
	      break;
	    case SP_GLYPH_SPACE:
	      break;
	    default:
	      fprintf (f, "\\spatium\n");
	      break;
	    }
	  key_change = 0;
	  new_line = 0;
	  return;
	}
      next_note = find_next_note (current_element, syllable);
      if (syllable->next_syllable && syllable->next_syllable->elements[0]
	  && syllable->next_syllable->elements[0]->type == GRE_END_OF_LINE)
	{
	  new_line = 1;
	}
      if (current_element->type == GRE_C_KEY_CHANGE)
	{
	  if (next_note != 0)
	    {
	      clef =
		gregorio_calculate_new_key (C_KEY,
					       current_element->element_type -
					       48);
	      if (new_line == 1)
		{
		  fprintf (f, "\\loff{\\custos ");
		}
	      else
		{
		  fprintf (f, "\\CUSTOS ");
		}
	      opustex_print_note (f, next_note);
	      if (new_line == 1)
		{
		  fprintf (f, "}\n");
		}
	      fprintf (f,
		       "\\setclefsymbol1\\gregorianCclef\n\\setclef1%d\n",
		       current_element->element_type - 48);
	      if (new_line == 1)
		{
		  fprintf (f, "\\lineaproxima\n");
		}
	      else
		{
		  fprintf (f, "\\changeclefs\n");
		}
	    }
	  key_change = 1;
	  new_line = 0;
	  return;
	}
      if (current_element->type == GRE_F_KEY_CHANGE)
	{
	  if (next_note != 0)
	    {
	      clef =
		gregorio_calculate_new_key (F_KEY,
					       current_element->element_type -
					       48);
	      if (new_line == 1)
		{
		  fprintf (f, "\\loff{\\custos ");
		}
	      else
		{
		  fprintf (f, "\\CUSTOS ");
		}
	      opustex_print_note (f, next_note);
	      if (new_line == 1)
		{
		  fprintf (f, "}\n");
		}
	      fprintf (f,
		       "\\setclefsymbol1\\gregorianFclef\n\\setclef1%d\n",
		       current_element->element_type - 46);
	      if (new_line == 1)
		{
		  fprintf (f, "\\lineaproxima\n");
		}
	      else
		{
		  fprintf (f, "\\changeclefs\n");
		}
	    }
	  key_change = 1;
	  new_line = 0;
	  return;
	}
      if (current_element->type == GRE_END_OF_LINE)
	{
	  if (next_note == 0
	      || (syllable->next_syllable
		  && syllable->next_syllable->elements[0]
		  && (syllable->next_syllable->elements[0]->type ==
		      GRE_C_KEY_CHANGE
		      || syllable->next_syllable->elements[0]->type ==
		      GRE_F_KEY_CHANGE)) || key_change == 1)
	    {
	    }
	  else
	    {
	      fprintf (f, "\\custos ");
	      opustex_print_note (f, next_note);
	      fprintf (f, "\n\\lineaproxima\n");
	    }
	  key_change = 0;
	  new_line = 1;
	  return;
	}
    }
  else
    {
      if (syllable->next_syllable)
	{
	  nextposition = syllable->next_syllable->position;
	}
      fprintf (f, "\\sgn ");
      opustex_write_text (f, syllable->text, first_syllable);
      while (current_element)
	{
	  if (current_element->type == GRE_SPACE)
	    {
	      switch (current_element->element_type)
		{
		case SP_NO_SPACE:
		  fprintf (f, "\\nonspatium");
		  break;
		case SP_ZERO_WIDTH:
		  fprintf (f, "\\Nonspatium");
		  break;
		case SP_NEUMATIC_CUT:
		  fprintf (f, "\\spatiumparvum");
		  break;
		case SP_LARGER_SPACE:
		  fprintf (f, " \\spatiumparvum");
		  break;
		case SP_GLYPH_SPACE:
		  break;
		default:
		  fprintf (f, "\\spatium");
		  break;
		}
	      current_element = current_element->next;
	      key_change = 0;
	      new_line = 0;
	      continue;
	    }
	  if (current_element->type == GRE_BAR)
	    {
	      fprintf (f, "\\");
	      opustex_write_barline (f,
						 current_element->
						 element_type);
	      fprintf (f, "\\spatium");	// OpusTeX: inside a neume, divisio needs to be followed by a spatium
	      current_element = current_element->next;
	      key_change = 0;
	      new_line = 0;
	      continue;
	    }
	  if (current_element->type == GRE_TEXVERB_ELEMENT)
	    {
	      if (current_element->texverb)
	        {
	          fprintf (f, "%s", current_element->texverb);
	        }
	      current_element = current_element->next;
	      key_change = 0;
	      new_line = 0;
	      continue;
	    }
	  if (current_element->type == GRE_C_KEY_CHANGE
	      || current_element->type == GRE_F_KEY_CHANGE)
	    {
	      gregorio_message (_
				   ("clef change inside of a syllable doesn't work in OpusTeX"),
				   "opustex_write syllable",
				   ERROR, 0);
	      current_element = current_element->next;
	      continue;
	    }
	  if (current_element->type == GRE_END_OF_LINE)
	    {
	      if (current_element->next
		  && current_element->next->type == GRE_BAR)
		{
		  gregorio_message (_
				       ("line break cannot be placed before a divisio in OpusTeX"),
				       "opustex_write syllable",
				       ERROR, 0);
		}
	      else
		{
		  next_note =
		    find_next_note (current_element, syllable);
		  if (next_note == 0
		      || (!(current_element->next)
			  && (syllable->next_syllable
			      && syllable->next_syllable->elements[0]
			      && (syllable->next_syllable->elements[0]->
				  type == GRE_C_KEY_CHANGE
				  || syllable->next_syllable->elements[0]->
				  type == GRE_F_KEY_CHANGE)))
		      || key_change == 1)
		    {
		    }
		  else
		    {
		      fprintf (f, "\\custos ");
		      opustex_print_note (f, next_note);
		      fprintf (f, "\\lineaproxima");
		    }
		}
	      current_element = current_element->next;
	      key_change = 0;
	      new_line = 1;
	      continue;
	    }
	  opustex_write_element (f, current_element);
	  current_element = current_element->next;
	  key_change = 0;
	  new_line = 0;
	  continue;
	}
      if (loff >= 1)
	{
	  fprintf (f, "}");
	}
      loff = 0;
      fprintf (f, "\\egn\n");
      if (nextposition
	  && ((nextposition == WORD_BEGINNING)
	      || (nextposition == WORD_ONE_SYLLABLE)))
	{
	  fprintf (f, "\\spatium\n");
	}
    }
  if (!(syllable->next_syllable) && finis == 0)
    {
      fprintf (f, "\\Finisgregoriana\n");
    }
}


void
otex_write_begin (FILE * f, unsigned char style)
{
  switch (style)
    {
    case ST_ITALIC:
      fprintf (f, "{\\it ");
      break;
    case ST_SMALL_CAPS:
      fprintf (f, "{\\sc ");
      break;
    case ST_BOLD:
      fprintf (f, "{\\bf ");
      break;
    case ST_FORCED_CENTER:
    case ST_CENTER:
      fprintf (f, "}{");
      break;
    case ST_TT:
      fprintf (f, "{\\tt ");
      break;
    default:
      break;
    }
}

void
otex_write_end (FILE * f, unsigned char style)
{
  switch (style)
    {
    case ST_FORCED_CENTER:
    case ST_CENTER:
      fprintf (f, "}{");
      break;
    default:
      fprintf (f, "}");
      break;
    }
}

void
otex_write_special_char (FILE * f, grewchar * special_char)
{
  if (!gregorio_wcsbufcmp(special_char, "'æ"))
    {
      fprintf (f, "\\'ae");
      return;
    }
  if (!gregorio_wcsbufcmp(special_char, "'œ"))
    {
      fprintf (f, "\\'oe");
      return;
    }
  if (!gregorio_wcsbufcmp(special_char, "ae"))
    {
      fprintf (f, "\\ae");
      return;
    }
  if (!gregorio_wcsbufcmp(special_char, "R/"))
    {
      fprintf (f, "\\s R");
      return;
    }
  if (!gregorio_wcsbufcmp(special_char, "A/"))
    {
      fprintf (f, "\\s A");
      return;
    }
  if (!gregorio_wcsbufcmp(special_char, "V/"))
    {
      fprintf (f, "\\s V");
      return;
    }
}

void
otex_write_verb (FILE * f, grewchar * verb_str)
{
  gregorio_print_unistring  (f, verb_str);
}

void
otex_print_char (FILE * f, grewchar to_print)
{
  switch (to_print)
    {
    case L'œ':
      fprintf (f, "\\oe ");
      break;
    case L'æ':
      fprintf (f, "\\ae ");
      break;
    case L'é':
      fprintf (f, "\\'e ");
      break;
    case L'è':
      fprintf (f, "\\`e ");
      break;
    case L'à':
      fprintf (f, "\\`a ");
      break;
    case L'ô':
      fprintf (f, "\\^o ");
      break;
    case L'î':
      fprintf (f, "\\^i ");
      break;
    case L'í':
      fprintf (f, "\\'i ");
      break;
    case L'û':
      fprintf (f, "\\^u ");
      break;
    case L'ê':
      fprintf (f, "\\^e ");
      break;
    case L'ó':
      fprintf (f, "\\'o ");
      break;
    default:
      gregorio_write_one_tex_char(f, to_print);
      break;
    }
}

void
opustex_write_text (FILE * f, gregorio_character * text,
				char *first_syllable)
{
  if (text == NULL)
    {
      fprintf (f, "{}{}{}");
      return;
    }
  fprintf (f, "{");
  gregorio_write_text (*first_syllable, text, f,
			  (&otex_write_verb),
			  (&otex_print_char),
			  (&otex_write_begin),
			  (&otex_write_end),
			  (&otex_write_special_char));
  if (*first_syllable)
    {
      *first_syllable = 0;
    }
  fprintf (f, "}");
}


void
opustex_write_element (FILE * f, gregorio_element * element)
{
  gregorio_glyph *current_glyph = element->first_glyph;
  while (current_glyph)
    {
      if (current_glyph->type == GRE_SPACE)
	{
	  // we assume here that it is a SP_ZERO_WIDTH, the only one a glyph can be
	  if (loff != 1)
	    {
	      fprintf (f, "\\Nonspatium");
	    }
	  current_glyph = current_glyph->next;
	  continue;
	}
      if (current_glyph->type == GRE_FLAT)
	{
	  fprintf (f, "\\bmolle ");
	  opustex_print_note (f, current_glyph->glyph_type);
	  current_glyph = current_glyph->next;
	  continue;
	}
      if (current_glyph->type == GRE_NATURAL)
	{
	  fprintf (f, "\\bdurum ");
	  opustex_print_note (f, current_glyph->glyph_type);
	  current_glyph = current_glyph->next;
	  continue;
	}
      if (current_glyph->type == GRE_BAR)
	{
	  fprintf (f, "\\");
	  opustex_write_barline (f, current_glyph->glyph_type);
	  fprintf (f, "\n\\spatium\n");
	  current_glyph = current_glyph->next;
	  continue;
	}
      // at this point glyph->type is GRE_GLYPH
      opustex_write_glyph (f, current_glyph);
      current_glyph = current_glyph->next;
    }
}

void
opustex_write_barline (FILE * f, char type)
{
  switch (type)
    {
    case B_VIRGULA:
      fprintf (f, "virgula");
      break;
    case B_DIVISIO_MINIMA:
      fprintf (f, "divisiominima");
      break;
    case B_DIVISIO_MINOR:
      fprintf (f, "divisiominor");
      break;
    case B_DIVISIO_MAIOR:
      fprintf (f, "divisiomaior");
      break;
    case B_DIVISIO_FINALIS:
      fprintf (f, "divisiofinalis");
      break;
    default:
      gregorio_message (_("unknown bar type"),
			   "opustex_write_barline", ERROR, 0);
      break;
    }
}

void
opustex_write_finis (FILE * f, char type)
{
  switch (type)
    {
    case B_DIVISIO_MAIOR:
      fprintf (f, "finisgregoriana");
      break;
    default:
      fprintf (f, "Finisgregoriana");
      break;
    }
}

void
opustex_write_glyph (FILE * f, gregorio_glyph * glyph)
{
  gregorio_note *current_note = NULL;
  int h_length = 0;
  int h_pitch = 0;
  unsigned char augmentum;

  if (!glyph)
    {
      gregorio_message (_
			   ("called with NULL pointer"),
			   "opustex_write_glyph", ERROR, 0);
      return;
    }
  if (glyph->type == GRE_TEXVERB_GLYPH)
    {
      if (glyph->texverb)
        {
          fprintf(f, "%s", glyph->texverb);
        }
      return;
    }
  if (!glyph->first_note)
    {
      gregorio_message (_
			   ("called with glyph without note"),
			   "opustex_write_glyph", ERROR, 0);
      return;
    }
  if (loff == 1)
    {
      fprintf (f, "\\loff{");
      loff++;
    }
  current_note = glyph->first_note;
  while (current_note)
    {
      if (current_note->signs >= _V_EPISEMUS)
	{
	  fprintf (f, "\\ictus ");
	  opustex_print_note (f, current_note->pitch);
	}
      current_note = current_note->next;
    }
  current_note = glyph->first_note;
  // divide puncta_inclinata into single glyphs
  if (is_puncta_inclinata (glyph->glyph_type)
      || glyph->glyph_type == G_PUNCTA_INCLINATA)
    {
      if (glyph->first_note->signs >= _V_EPISEMUS)
	{
	  fprintf (f, "\\ictus ");
	  opustex_print_note (f, glyph->first_note->pitch);
	}
      fprintf (f, "\\punctuminclinatum ");
      opustex_print_note (f, glyph->first_note->pitch);
      current_note = glyph->first_note->next;
      while (current_note)
	{
	  fprintf (f, "\\nonspatium");
	  if (simple_htype(current_note->h_episemus_type == H_ALONE))
	    {
	      opustex_print_episem (f, current_note->pitch, 1);
	    }
	  if (current_note->signs >= _V_EPISEMUS)
	    {
	      fprintf (f, "\\ictus ");
	      opustex_print_note (f, current_note->pitch);
	    }
	  fprintf (f, "\\punctuminclinatum ");
	  opustex_print_note (f, current_note->pitch);
	  current_note = current_note->next;
	}
      return;
    }
  else
    {
      if (glyph->glyph_type != G_PES)
	{
	  while (current_note)
	    {
	      if (simple_htype(current_note->h_episemus_type == H_ALONE))
		{
		  opustex_print_episem (f, current_note->pitch,
						    1);
		}
	      if (simple_htype(current_note->h_episemus_type == H_MULTI))
		{
		  h_length++;
		  h_pitch = current_note->h_episemus_top_note;
		}
	      current_note = current_note->next;
	    }
	  if (h_length > 0)
	    {
	      opustex_print_episem (f, h_pitch, h_length);
	    }
	}
      else
	{
	  if (simple_htype(glyph->first_note->h_episemus_type) != H_NO_EPISEMUS)
	    {
	      opustex_print_episem_under (f,
						      glyph->first_note->
						      pitch, 1);
	    }
	  if (simple_htype(glyph->first_note->next->h_episemus_type) != H_NO_EPISEMUS)
	    {
	      opustex_print_episem (f,
						glyph->first_note->next->
						pitch, 1);
	    }
	}

    }
  // special shapes
  if (glyph->glyph_type == G_DISTROPHA_AUCTA)
    {
      fprintf (f, "\\strophaaucta ");
      opustex_print_note (f, glyph->first_note->pitch);
      fprintf (f, "\\spatiumparvum\\strophaaucta ");
      opustex_print_note (f, glyph->first_note->pitch);
      return;
    }
  if (glyph->glyph_type == G_TRISTROPHA_AUCTA)
    {
      fprintf (f, "\\strophaaucta ");
      opustex_print_note (f, glyph->first_note->pitch);
      fprintf (f, "\\spatiumparvum\\strophaaucta ");
      opustex_print_note (f, glyph->first_note->pitch);
      fprintf (f, "\\spatiumparvum\\strophaaucta ");
      opustex_print_note (f, glyph->first_note->pitch);
      return;
    }
  if (glyph->glyph_type == G_PUNCTUM && glyph->first_note->shape == S_ORISCUS)
    {
      fprintf (f, "\\oriscus ");
      opustex_print_note (f, glyph->first_note->pitch);
      return;
    }
  if (glyph->glyph_type == G_PUNCTUM
      && glyph->first_note->shape == S_ORISCUS_AUCTUS)
    {
      fprintf (f, "\\oriscusreversus ");
      opustex_print_note (f, glyph->first_note->pitch);
      return;
    }
  if (glyph->glyph_type == G_PUNCTUM
      && glyph->first_note->shape == S_QUILISMA)
    {
      fprintf (f, "\\quilisma ");
      opustex_print_note (f, glyph->first_note->pitch);
      return;
    }
  // pes quassus
  if (glyph->glyph_type == G_PES && glyph->first_note->shape == S_ORISCUS)
    {
      fprintf (f, "\\pesquassus ");
    }
  else
    {
      // quilisma
      if (glyph->first_note->shape == S_QUILISMA
	  && (glyph->glyph_type == G_PES || glyph->glyph_type == G_TORCULUS))
	{
	  fprintf (f, "\\%s%s", "quilisma",
		   opustex_glyph_type_to_str (glyph->glyph_type));
	}
      else
	{
	  if (glyph->first_note->shape == S_QUILISMA
	      && glyph->glyph_type == G_PES_QUADRATUM)
	    {
	      fprintf (f, "\\%s%s", "Quilisma",
		       opustex_glyph_type_to_str (glyph->
							      glyph_type));
	    }
	}
    }

  if (glyph->liquescentia)
    {
      opustex_print_liquescentia (f, glyph->liquescentia,
					      glyph->glyph_type);
    }
  fprintf (f, " ");
  //print the notes of the glyph
  current_note = glyph->first_note;
  while (current_note)
    {
      opustex_print_note (f, current_note->pitch);
      current_note = current_note->next;
    }

  current_note = glyph->first_note;
  while (current_note)
    {
      if (current_note->signs == _PUNCTUM_MORA
	  || current_note->signs == _V_EPISEMUS_PUNCTUM_MORA)
	{
	  fprintf (f, "\\augmentum ");
	  opustex_print_augmentum_note (f, current_note->pitch);
	  augmentum = 1;
	}
      if (current_note->signs == _AUCTUM_DUPLEX
	  || current_note->signs == _V_EPISEMUS_AUCTUM_DUPLEX)
	{
	  fprintf (f, "\\augmentumduplex ");
	  opustex_print_augmentum_note (f, current_note->pitch);
	  opustex_print_augmentum_note (f,
						    current_note->
						    previous->pitch);
	  augmentum = 1;
	}
      current_note = current_note->next;
    }

  if (augmentum == 1 && glyph->next
      && glyph->next->type == GRE_SPACE
      && glyph->next->glyph_type == SP_ZERO_WIDTH)
    loff++;
}

void
opustex_print_note (FILE * f, char pitch)
{
  if (is_even (clef))
    {
      if (pitch - clef < 104)
	{
	  fprintf (f, "%c", pitch - clef - 25);
	}
      else
	{
	  fprintf (f, "%c", pitch - clef - 7);
	}
    }
  else
    {
      if (pitch - clef < 97)
	{
	  fprintf (f, "%c", pitch - clef - 18);
	}
      else
	{
	  fprintf (f, "%c", pitch - clef);
	}
    }
}

void
opustex_print_episem (FILE * f, char pitch, char length)
{
  int realpitch;

  if (is_even (clef))
    {
      if (pitch - clef < 104)
	{
	  realpitch = pitch - clef - 25;
	}
      else
	{
	  realpitch = pitch - clef - 7;
	}
    }
  else
    {
      if (pitch - clef < 97)
	{
	  realpitch = pitch - clef - 18;
	}
      else
	{
	  realpitch = pitch - clef;
	}
    }
  if (!is_even (pitch) && pitch < 'k')	// if the note is between staff lines
    {
      fprintf (f, "\\episem %c%d", realpitch + 2, length);
    }
  else
    {
      fprintf (f, "\\episem %c%d", realpitch + 1, length);
    }
}

void
opustex_print_episem_under (FILE * f, char pitch, char length)
{
  int realpitch;

  if (is_even (clef))
    {
      if (pitch - clef < 104)
	{
	  realpitch = pitch - clef - 25;
	}
      else
	{
	  realpitch = pitch - clef - 7;
	}
    }
  else
    {
      if (pitch - clef < 97)
	{
	  realpitch = pitch - clef - 18;
	}
      else
	{
	  realpitch = pitch - clef;
	}
    }
  if (!is_even (pitch) && pitch > 'c')	// if the note is between staff lines
    {
      fprintf (f, "\\episem %c%d", realpitch - 2, length);
    }
  else
    {
      fprintf (f, "\\episem %c%d", realpitch - 1, length);
    }
}


void
opustex_print_augmentum_note (FILE * f, char pitch)
{
  int realpitch;

  if (is_even (clef))
    {
      if (pitch - clef < 104)
	{
	  realpitch = pitch - clef - 25;
	}
      else
	{
	  realpitch = pitch - clef - 7;
	}
    }
  else
    {
      if (pitch - clef < 97)
	{
	  realpitch = pitch - clef - 18;
	}
      else
	{
	  realpitch = pitch - clef;
	}
    }
  if (is_even (realpitch))
    {
      fprintf (f, "%c", realpitch);
    }
  else
    {
      fprintf (f, "%c", realpitch + 1);
    }
}

const char *
opustex_glyph_type_to_str (char name)
{
  const char *str = "";
  switch (name)
    {
    case G_PUNCTUM_INCLINATUM:
      str = "punctuminclinatum";
      break;
    case G_TRIGONUS:
      str = "trigonus";
      break;
    case G_VIRGA:
      str = "virga";
      break;
    case G_STROPHA:
      str = "stropha";
      break;
    case G_PUNCTUM:
      str = "punctum";
      break;
    case G_PES:
      str = "pes";
      break;
    case G_PES_QUADRATUM:	//doesn't exist in OpusTeX
      str = "pes";
      gregorio_message (_("pes quadratum doesn't exist in OpusTeX"),
			   "opustex_glyph_type_to_str", ERROR, 0);
      break;
    case G_FLEXA:
      str = "clivis";
      break;
    case G_TORCULUS:
      str = "torculus";
      break;
    case G_TORCULUS_RESUPINUS:
      str = "torculusresupinus";
      break;
    case G_TORCULUS_RESUPINUS_FLEXUS:
      gregorio_message (_
			   ("torculus_resupinus_flexus doesn't exist in OpusTeX"),
			   "opustex_glyph_type_to_str", ERROR, 0);
      break;
    case G_PORRECTUS:
      str = "porrectus";
      break;
    case G_PORRECTUS_FLEXUS:
      str = "porrectusflexus";
      break;
    case G_BIVIRGA:
      str = "varbivirga";
      break;
    case G_TRIVIRGA:
      str = "vartrivirga";
      break;
    case G_DISTROPHA:
      str = "distropha";
      break;
    case G_TRISTROPHA:
      str = "tristropha";
      break;
    case G_SCANDICUS:
      str = "scandicus";
      break;
    default:
      break;
    }
  return str;
}

void
opustex_print_liquescentia (FILE * f, char liquescentia,
					char glyph)
{
  const char *suffix = "us";
  if (glyph == G_FLEXA || glyph == G_STROPHA)
    {
      suffix = "a";
    }
  if (glyph <= G_PUNCTUM_INCLINATUM)
    {
      suffix = "um";
    }
  switch (liquescentia)
    {
    case L_DEMINUTUS:
      if (glyph == G_TORCULUS || glyph == G_PORRECTUS
	  || glyph == G_TORCULUS_RESUPINUS)
	{
	  fprintf (f, "deminutus");
	}
      else
	{
	  gregorio_message (_("that glyph cannot be deminutus in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_AUCTUS_ASCENDENS:
      if (glyph == G_PUNCTUM || glyph == G_PES || glyph == G_FLEXA)
	{
	  fprintf (f, "auct%sascendens", suffix);
	}
      else
	{
	  gregorio_message (_
			       ("that glyph cannot be auctus ascendens in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_AUCTUS_DESCENDENS:
      if (glyph == G_PUNCTUM || glyph == G_PES || glyph == G_FLEXA
	  || glyph == G_TORCULUS || glyph == G_PORRECTUS)
	{
	  fprintf (f, "auct%sdescendens", suffix);
	}
      else
	{
	  gregorio_message (_
			       ("that glyph cannot be auctus descendens in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_AUCTA:
      if (glyph == G_PUNCTUM_INCLINATUM || glyph == G_STROPHA)
	{
	  fprintf (f, "auct%s", suffix);
	}
      else
	{
	  gregorio_message (_("that glyph cannot be auctus in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_INITIO_DEBILIS:
      if (glyph == G_PES || glyph == G_TORCULUS || glyph == G_PORRECTUS)
	{
	  fprintf (f, "initiodebilis");
	}
      else
	{
	  gregorio_message (_
			       ("that glyph cannot have initio debilis in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_DEMINUTUS_INITIO_DEBILIS:
      if (glyph == G_TORCULUS)
	{
	  fprintf (f, "deminitusinitiodebilis");
	}
      else
	{
	  gregorio_message (_
			       ("that glyph cannot be deminutus initio debilis in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_AUCTUS_ASCENDENS_INITIO_DEBILIS:
      gregorio_message (_
			   ("there's no auctus ascendens initio debilis in OpusTeX"),
			   "opustex_print_liquescentia", ERROR,
			   0);
      break;
    case L_AUCTUS_DESCENDENS_INITIO_DEBILIS:
      if (glyph == G_PES || glyph == G_TORCULUS)
	{
	  fprintf (f, "auctus descendens initiodebilis");
	}
      else
	{
	  gregorio_message (_
			       ("that glyph cannot be auctus descendens initio debilis in OpusTeX"),
			       "opustex_print_liquescentia",
			       ERROR, 0);
	}
      break;
    case L_AUCTA_INITIO_DEBILIS:
      gregorio_message (_("there's no aucta initio debilis in OpusTeX"),
			   "opustex_print_liquescentia", ERROR,
			   0);
      break;
    }
}

char
find_next_note (gregorio_element * current_element,
			    gregorio_syllable * current_syllable)
{
  gregorio_element *next_element = current_element->next;
  gregorio_element *element_element = NULL;
  char stop = 0;
  gregorio_glyph *next_glyph = NULL;

  while (stop == 0)
    {
      if (next_element)
	{
	  if (next_element->type == GRE_ELEMENT)
	    {
	      element_element = next_element;
	      stop = 1;
	    }
	  else
	    {
	      next_element = next_element->next;
	    }
	}
      else
	{
	  if (current_syllable->next_syllable)
	    {
	      current_syllable = current_syllable->next_syllable;
	      next_element = current_syllable->elements[0];
	    }
	  else
	    {
	      stop = 1;
	    }
	}
    }
  if (element_element)
    {
      next_glyph = element_element->first_glyph;
      while (next_glyph->type != GRE_GLYPH)
	{
	  next_glyph = next_glyph->next;
	}
    }
  if (next_glyph)
    {
      return next_glyph->first_note->pitch;
    }
  return 0;
}
